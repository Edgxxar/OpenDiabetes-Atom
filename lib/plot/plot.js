'use babel';

/** @jsx etch.dom */

import etch from 'etch';
import path from 'path';
import fs from 'fs-extra';
import md5 from 'md5-file/promise';
import util from '../util';
import Toolbar from "./toolbar";
import Canvas from "./canvas";
import {Writable} from 'stream';
import {StringDecoder} from 'string_decoder';

/**
 * Plot has a directory that is watched for file changes.
 * Plots in the directory can be generated by tag, or with a file directly.
 */
export default class Plot {
  /**
   * Current status of this plot. Either idle, export or generate
   */
  status = 'idle';
  /**
   * The process currently generating plots, if in status generate
   */
  process = null;

  constructor(properties) {
    this.view = properties.view;
    this.serialized = properties.serialized;
    etch.initialize(this);
  }

  render() {
    const toolbar = this.serialized ? this.serialized.toolbar : null;
    const canvas = this.serialized ? this.serialized.canvas : null;
    return (
      <div className="odf-plot">
        <Toolbar ref="toolbar" serialized={toolbar} plot={this}/>
        <Canvas ref="canvas" serialized={canvas}/>
      </div>
    );
  }

  setCanvas(url) {
    if (url) {
      this.refs.canvas.renderPdf(url);
    } else {
      this.refs.canvas.clearPdf();
    }
  }

  /**
   * Exports data for the given tag and generates plot for the exported file.
   * @param tag
   */
  generatePlots(tag) {
    if (this.status !== 'idle') {
      throw new Error(`Cannot export tag while in status ${this.status}!`);
    }
    const toolbar = this.refs.toolbar;
    util.checkDockerImage('plotteria').then(() => {
      this.status = 'export';

      toolbar.updateProgress(-1, 'Exporting data...');

      // export
      let xprt;
      if (tag) {
        xprt = util.executeCli('exporttagged', {
          type: 'ODV_CSV',
          tag: tag
        });
      } else {
        xprt = util.executeCli('export', {
          type: 'ODV_CSV'
        });
      }
      // after export grep exported file
      xprt.then(result => {
        let file = result.match(/Export to file: (.+\.csv)/);
        if (!Array.isArray(file) || file.length < 2) {
          atom.notifications.addError('Export unsuccessful!', {
            detail: result
          });
          this.status = 'idle';
          return;
        }
        file = path.join(util.getProjectPath(), 'export', file[1]);

        // generate hash for file
        md5(file)
          .then(hash => {
            this.setTagCache(tag, hash);
            // generate directory
            if (this.status === 'export') {
              const dir = path.join(util.getProjectPath(), 'plots', hash);
              return fs.mkdirs(dir).then(() => Promise.resolve(dir));
            } else return Promise.reject('SIGTERM');
          })
          .then(dir => {
            // generate plots
            if (this.status === 'export') {
              this.status = 'generate';
              toolbar.watchFiles(dir);

              const cmd = util.buildCommand('plot')
              // construct container path to config
                .replace('%config%', '/mnt/module/plotteria/config.ini')
                // construct container path to file
                .replace('%file%', '/mnt/project/' + path.posix.format(path.parse(atom.project.relativizePath(file)[1])))
                // construct container path to output directory
                .replace('%out%', '/mnt/project/' + path.posix.format(path.parse(atom.project.relativizePath(dir)[1])));

              return new Promise((resolve, reject) => {
                const docker = util.getDocker();
                docker.run('plotteria', util.splitCommandArgs(cmd), [new MyWritable(), new MyWritable()], {
                  Tty: false,
                  HostConfig: {
                    Binds: [
                      path.resolve(util.getModulePath(), '..', 'docker') + ':/mnt/module',
                      util.getProjectPath() + ':/mnt/project'
                    ]
                  }
                }, {}, (err, data, container) => {
                  if (atom.config.get('open-diabetes-filter.docker-cleanup')) {
                    container.remove().then(() => resolve(data));
                  } else resolve(data);
                }).on('container', container => {
                  if (this.status === 'generate') {
                    toolbar.updateProgress(-1, 'Generating plots...');
                    this.process = container;
                  } else {
                    container.kill().then(() => reject('SIGTERM'))
                  }
                });
              });
            } else return Promise.reject('SIGTERM');
          })
          .then(data => {
            console.log(`plot finished with error ${data.Error} and code ${data.StatusCode}`);
            toolbar.stopProgress();
            this.status = 'idle';
            this.process = null;
          })
          .catch(err => {
            if (err !== 'SIGTERM') {  // if not cancelled
              console.error(err);
              atom.notifications.addError('Error while generating plots!', {
                detail: err
              });
            }
            toolbar.stopProgress();
            this.status = 'idle';
            this.process = null;
          })
      });
    }).catch(() => {
      toolbar.stopProgress();
    })
  }

  cancelPlots() {
    if (this.status === 'idle')
      throw new Error(`Cannot cancel plot generation while in status ${this.status}!`);

    if (this.process !== null && typeof this.process === 'object')
      this.process.kill();
    this.status = 'idle';
    this.process = null;
  }

  hasTagCached(tag) {
    if (tag === null)
      tag = '__ALL';
    return this.view.tagCache.hasOwnProperty(tag);
  }

  getTagCache(tag) {
    if (tag === null)
      tag = '__ALL';
    return this.view.tagCache[tag];
  }

  setTagCache(tag, hash) {
    if (tag === null)
      tag = '__ALL';
    this.view.tagCache[tag] = hash;
  }

  getTag() {
    return this.refs.toolbar.getTag();
  }

  serialize() {
    return {
      toolbar: this.refs.toolbar.serialize(),
      canvas: this.refs.canvas.serialize()
    };
  }

  destroy() {
    etch.destroy(this);
  }

  update() {
    etch.update(this);
  }
}

class MyWritable extends Writable {
  constructor(options) {
    super(options);
    const state = this._writableState;
    this._decoder = new StringDecoder(state.defaultEncoding);
    this.data = '';
  }

  _write(chunk, encoding, callback) {
    if (encoding === 'buffer') {
      chunk = this._decoder.write(chunk);
    }
    this.data += chunk;
    callback();
  }

  _final(callback) {
    this.data += this._decoder.end();
    console.log(this.data);
    callback();
  }
}
