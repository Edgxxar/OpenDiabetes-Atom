'use babel';

/** @jsx etch.dom */

import etch from 'etch';
import path from 'path';
import cp from 'child_process';
import uuidv5 from 'uuid/v5';
import util from '../util';
import Toolbar from "./toolbar";
import Canvas from "./canvas";

// random UUID used for generating UUIDs for tags
const UUID_TAG = '10ad83c0-348b-475c-944d-6e40295e2ea8';
// random UUID used for generating UUIDs for files
const UUID_FILE = '9aa209f5-fdb1-454e-90fb-dfe4964f6e41';

/**
 * Plot has a directory that is watched for file changes.
 * Plots in the directory can be generated by tag, or with a file directly.
 */
export default class Plot {
  uuid = UUID_TAG;
  status = 'idle';
  process = null;

  constructor(properties) {
    this.view = properties.view;

    etch.initialize(this);
  }

  render() {
    return (
      <div className="odf-plot">
        <Toolbar ref="toolbar" plot={this}/>
        <Canvas ref="canvas"/>
      </div>
    );
  }

  setCanvas(url) {
    this.refs.canvas.renderPdf(url);
  }

  generateByTag(tag) {
    if (this.status !== 'idle') {
      throw new Error(`Cannot export tag while in status ${this.status}!`);
    }
    this.status = 'export';
    const toolbar = this.refs.toolbar;
    toolbar.updateProgress(-1, 'Exporting data...');

    let xprt;
    if (tag) {
      this.setTagUUID(tag);               // generate repeatable uuid for this tag
      xprt = util.executeCli('exporttagged', {
        'type': 'ODV_CSV',
        'tag': tag
      }, false);
    } else {
      this.uuid = UUID_TAG;               // use namespace uuid for untagged data
      xprt = util.executeCli('export', {
        'type': 'ODV_CSV'
      }, false);
    }
    const directory = this.getCurrentDirectory();

    // export data and prepare plot output dir
    Promise.all([xprt, util.mkdir(directory)])
    // generate plots
      .then(result => {
        const file = result[0].match(/Export to file: (.+_export\.csv)/);
        if (!Array.isArray(file) || file.length < 2) {
          //TODO: fail
          return;
        }
        this.status = 'generate';
        this.generatePlots(path.join(util.getProjectPath(), 'export', file[1]), directory);
      });
  }

  generateByFile(file) {
    if (this.status !== 'idle') {
      throw new Error(`Cannot export tag while in status ${this.status}!`);
    }
    this.status = 'generate';
    this.setFileUUID(file);               // generate repeatable uuid for this file
    const directory = this.getCurrentDirectory();

    util.mkdir(directory).then(() => this.generatePlots(file, directory));
  }

  generatePlots(file, out) {
    if (this.status !== 'generate') {
      throw new Error(`Cannot generate plots while in status ${this.status}!`);
    }

    const toolbar = this.refs.toolbar;
    toolbar.updateProgress(-1, 'Generating plots...');
    toolbar.watchFiles(out);

    const plot = atom.config.get('open-diabetes-filter.plot');
    const cmd = atom.config.get('open-diabetes-filter.commands.plot')
      .replace('%plot%', plot)
      .replace('%file%', file)
      .replace('%out%', out);
    const args = util.splitCommandArgs(cmd);
    const exec = args.shift();
    const prc = cp.spawn(exec, Object.freeze(args), {
      cwd: util.getProjectPath(),
      windowsHide: true,
    });
    prc.stdout.on('data', chunk => console.log(chunk.toString('utf8')));
    prc.stderr.on('data', chunk => console.error(chunk.toString('utf8')));
    prc.on('close', (code, signal) => {
      console.log(`process finished with code ${code} and signal ${signal}`);
      toolbar.stopProgress();
      this.status = 'idle';
    });
    this.process = prc;
  }

  cancelPlots() {
    if (this.status !== 'generate') {
      throw new Error(`Cannot cancel plot generation while in status ${this.status}!`);
    }

    this.process.kill();
    this.status = 'idle';
  }

  setFileUUID(file) {
    this.uuid = uuidv5(file, UUID_FILE);
  }

  setTagUUID(tag) {
    this.uuid = uuidv5(tag, UUID_TAG);
  }

  getCurrentDirectory() {
    return path.join(util.getProjectPath(), 'plots', this.uuid);
  }

  getTag() {
    return this.refs.toolbar.getTag();
  }

  destroy() {
    etch.destroy(this);
  }

  update() {
    etch.update(this);
  }
}
